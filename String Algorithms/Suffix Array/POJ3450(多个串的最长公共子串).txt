POJ3450

maxn = 4000
maxl = 200

method 1:

对于第一个串 枚举(or 二分长度为len的)子串，用KMP匹配其余的每个串(3999个), 每次匹配(O(200)), 取最小值
所有最小值中最大的那个就是解
O((200 or log200) * 3999 * 200)


method 2: (to be made sure...)

把2~3999个串塞入AC自动机, O(3999 * 200)
对于第一个串 枚举子串O(200)，用AC自动机匹配其余的每个串(走一遍O(3999+200)), 取最小值
所有最小值中最大的那个就是解

对于 AC自动机来说时间复杂性为：O(L(T)+max(L(Pi))+m) // m是模式串的数量
其中L为串的长度函数，P是模式串，T是目标串


method 3: (suffix array) 思想基于两个串的最长公共子串

这次用后缀数组。 

把n个字符串连接起来(len = 4000 * 200)，
中间用不同的且输入串中不会出现的字符隔开，
对新生成串的每个字符根据所在原子串划分区域，用Loc数组标记

预处理后缀数组(O(len * log(len)))
二分公共子串长度(log200)，查找相邻的后缀中是否有连续n个后缀的height值大于枚举值(O(4000))，且分属于n个不同的串。

总复杂度(O(len* log(len)))

// method 3 可以推广到 POJ3294

